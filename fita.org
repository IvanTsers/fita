#+begin_export latex
\section{Introduction}
The search of genetic markers in whole genome sequences (as
implemented in \texttt{fur}~\cite{hau21:fur}) requires finding a set
of closely realted genomes making up a \textit{phylogenetic
  neighborhood}, which may include hundreds of genomes. The Neighbors
package~\cite{hau23:nei} allows to discover the phylogenetic
neighborhood using automated parsing of NCBI taxonomy. The result of
the parsing is a set of genomic accessions separated into two groups:
\textbf{targets} and \textbf{neighbors}. However, the NCBI taxonomy
trees and whole-genome phylogenetic trees are not always reflect each
other~\cite{hau23:nei}, so it is recommended to check the results of
Neighbors pipeline through phylogeny analysis. The latter requires
\textit{de novo} reconstruction of phylogeny of hundreds of genomes
followed by inspection of large phylogenetic trees. Efficient tools
for large-sample phylogenetic analysis do present ~\cite{kloe19:phy},
but there are no tools allowing automated separation of targets and
neighbors. The given document introduces \texttt{fita}, a program for
dealing with the latter task.

\section{Approach}
We begin with an assumption that the target genomes are more similar
to each other than to any of the neighbor genomes. Thus, all the
targets are expected to form a clade on a phylogenetic tree. Now let's
consider an intentionally small example: we have 8 genome sequences in
a phylogenetic neighborhood predicted with Neighbors, 3 of them are
marked as \textbf{targets}, 5 other are \textbf{neighbors}. We plot a
phylogenetic tree for these sequences (Figure~\ref{fig:cladeExample}).

\begin{figure}[H]
  \begin{center}
    \includegraphics{cladeExample}
    \end{center}
  \caption{The sample phylogenetic tree reconstructed from an
    imaginary phylogenetic neighborhood predicted with the Neighbors
    package. The terminal nodes (encircled), or leaves, represent
    genomes. Target leaves are filled with
    grey.}\label{fig:cladeExample}
\end{figure}

A clade rooted on the node \textbf{2} is the lowest common ancestor of
all putative targets (nodes \textbf{10}, \textbf{13}, and
\textbf{15}). If we consider this a target clade, we have also to
consider the nodes \textbf{12}, \textbf{7}, \textbf{8}, and
\textbf{14} to be targets too. Some targets do can be misclassified by
Neighbors~\cite{hau23:nei}, but in this case we get almost all
accessions misclassified. Thus, instead of finding the common ancestor
of \textit{all} predicted targets, we want finding a node which roots
\textit{most} of the predicted targets. It is the node \textbf{6}. In
this case, we have only one node misclassified (\textbf{15}) and this
seems to be much more plausible.

In the example above, we have the target nodes marked, so we can
locate the target clade visually. This intuitive analysis has to be
formalized for working with the text trees. I suggest the following
algorithm:

\begin{enumerate}
\item start with the root of the input tree;
\item pick the child nodes of the root;
\item select the child that roots a subtree containing more target
  leaves than the subtree rooted by the other child;
\item set the selected child to be a new root;
\item repeat the previous 3 steps until we reject a clade consisting
  of predicted targets completely;
\item return the resulting subtree.
\end{enumerate}

Thus, by subsequent removal of non-target leaves from the tree, we
will reach the node that is the common ancestor for all targets and
some of their closest neighbors. The resulting tree is much smaller
than the original one, since almost all neighbors are removed from
it. Such a tree is easier to analyze.

These steps are implemented in \texttt{fita} (\textbf{fi}nd
\textbf{ta}rgets).

\section{Implementation}
The program \texttt{fita} has the main function logic and additional
hooks for auxillary variables, functions, and imports.
#+end_export

#+begin_src go <<fita.go>>=
  package main

  import (
	  //<<Imports>>
  )

  //<<Auxillary variables>>
  //<<Functions>>

  func main() {
	  //<<Main function>>
  }
#+end_src

#+begin_export latex
In the main function we set the usage, declare and parse the options,
read the input files, find the root node, perform iterative voting,
and print the results.
#+end_export

#+begin_src go <<Main function>>=
  //<<Set usage>>
  //<<Declare options>>
  //<<Parse options>>
  //<<Read input>>
  //<<Find the root and its children>>
  //<<Iterative voting>>
  //<<Print the results>>
#+end_src

#+begin_export latex
The usage consists of the actual usage message, an explanation of the
purpose of \texttt{fita}, and an example command.
#+end_export

#+begin_src go <<Set usage>>=
  u := "fita [tree file]... [target list file]..."
  p := "Find the target clade subtree."
  e := "fita -t tree.nwk -l targets.txt"
  clio.Usage(u, p, e)
#+end_src

#+begin_export latex
We import \texttt{clio}.
#+end_export

#+begin_src go <<Imports>>=
  "github.com/evolbioinf/clio"
#+end_src

#+begin_export latex
The user can set the name of the input files (\texttt{-t} for the tree
and \texttt{-l} for the list of targets), and set the name of the output
file (\texttt{-o}).
#+end_export

#+begin_src go <<Declare options>>=
  var optT = flag.String("t", "", "the input tree")
  var optL = flag.String("l", "", "list of the targets")
  var optS = flag.Bool("s", false, "print the run stats")
#+end_src

#+begin_export latex
  We import \texttt{flag}.
#+end_export

#+begin_src go <<Imports>>=
  "flag"
#+end_src

#+begin_export latex
We parse the options.
#+end_export

#+begin_src go <<Parse options>>=
  flag.Parse()
#+end_src

#+begin_export latex
We read a \texttt{Newick} tree from a file using a scanner from the
\texttt{nwk} package.
#+end_export

#+begin_src go <<Read input>>=
  treePath := *optT

  treeFile, err := os.Open(treePath)
  if err != nil {
	  fmt.Printf("couldn’t open %q\n", treePath)
	  os.Exit(1)
  }
  defer treeFile.Close()
  sc := nwk.NewScanner(treeFile)
  sc.Scan()
#+end_src

#+begin_export latex
We import \texttt{os} and \texttt{nwk}.
#+end_export

#+begin_src go <<Imports>>=
  "os"
  "github.com/evolbioinf/nwk"
  "fmt"
#+end_src

#+begin_export latex
We read the list of target names.
#+end_export

#+begin_src go <<Read input>>=
  targetListPath := *optL

  targetListFile, err := os.Open(targetListPath)
  if err != nil {
	  fmt.Printf("couldn’t open %q\n", targetListPath)
	  os.Exit(1)
  }
  defer targetListFile.Close()

  var targetList []string
  tarsc := bufio.NewScanner(targetListFile)
  for tarsc.Scan() {
	  targetList = append(targetList, tarsc.Text())
  }
#+end_src

#+begin_export latex
We import \texttt{bufio}.
#+end_export

#+begin_src go <<Imports>>=
  "bufio"
#+end_src

#+begin_export latex
We initialize 3 variables:
\begin{description}
\item[\texttt{cRoot}] to track the current root node;
\item[\texttt{rChild}] for the right child of the current root.
\item[\texttt{lChild}] for the left child of the current root.
\end{description}
The initial values are the root of the input tree and its respective
children.
#+end_export

#+begin_src go <<Find the root and its children>>=
  var cRoot *nwk.Node = sc.Tree()
  var rChild *nwk.Node = cRoot.Child
  var lChild *nwk.Node = rChild.Sib
#+end_src

#+begin_export latex
The essence of the 'voting' is to decide which of the two clades
(\texttt{rChild} or \texttt{lChild}) has more target leaves (votes)
--this is the winning clade. After the winning clade is defined, we
move to its root and repeat the voting. We do this until a losing
clade (which has less target leaves than the winning one) contains
only target leaves.  We initialize \texttt{losLeaves} and
\texttt{losLeaves} to keep the total number of leaves and votes in
the losing clade. We also declare \texttt{winVotes},
\texttt{winLeaves}, and \texttt{rounds} (number of voting rounds)
to be able to print out summary.
#+end_export

#+begin_src go <<Auxillary variables>>=
  var losLeaves int = 1
  var losVotes int = 0
  var winVotes int = 0
  var winLeaves []string
  var round int = 0
#+end_src

#+begin_export latex
The voting itself has the following steps:
\begin{enumerate}
\item get the labels of leaves of a subtree;
\item count targets among these leaves;
\item choose the winning clade
\end{enumerate}

#+end_export

#+begin_src go <<Iterative voting>>=
  for losVotes != losLeaves {
	  //<<Get leaf labels>>
	  //<<Count votes>>
	  //<<Choose winner>>
	  round++
	  cRoot = cRoot.Parent
  }
#+end_src

#+begin_export latex
The recursive function \texttt{getLeafLabels(n)} returns a slice of
the leaf labels of a subtree rooted on the node \texttt{n}.
#+end_export

#+begin_src go <<Functions>>=
  func getLeafLabels(n *nwk.Node) []string {
	  if n.Child == nil {
		  labelsTemp = append(labelsTemp, n.Label)
	  } else {
		  getLeafLabels(n.Child.Sib)
		  getLeafLabels(n.Child)
	  }
	  return labelsTemp
  }

#+end_src

#+begin_export latex
We declare \texttt{labelsTemp}.
#+end_export

#+begin_src go <<Auxillary variables>>=
  var labelsTemp []string
#+end_src

#+begin_export latex
We apply \texttt{getLeafLabels()} to the children of the current root
to get slices of the leaf labels. As the returned slice
(\texttt{labelsTemp}) is declared outside the
\texttt{getLeafLabels()}, we reset it after we call the function.
#+end_export

#+begin_src go <<Get leaf labels>>=
  rLeafLabels = getLeafLabels(rChild)
    labelsTemp = nil
  lLeafLabels = getLeafLabels(lChild)
    labelsTemp = nil
#+end_src

#+begin_export latex
We declare \texttt{rLeafLabels} and \texttt{lLeafLabels}.
#+end_export

#+begin_src go <<Auxillary variables>>=
var rLeafLabels, lLeafLabels []string
#+end_src

#+begin_export latex
We declare a function for checking if a string is present in a slice
of strings.
#+end_export

#+begin_src go <<Functions>>=
  func isInString(slice []string, value string) bool {
	  for _, x := range slice {
		  if x == value {
			  return true
		  }
	  }
	  return false
  }
#+end_src

#+begin_export latex
We count votes.
#+end_export

#+begin_src go <<Count votes>>=
  rVotes = countVotes(rLeafLabels, targetList)
  lVotes = countVotes(lLeafLabels, targetList)
#+end_src

#+begin_export latex
We declare function for votes counting.
#+end_export

#+begin_src go <<Functions>>=
  func countVotes(leaves []string, targets []string) int {
	  votes := 0
	  for _, leaf := range leaves {
		  if isInString(targets, leaf){
			  votes++
		  }
	  }
  return votes
  }
#+end_src

#+begin_export latex
The initial value of \texttt{rVotes} and \texttt{lVotes} is zero.
#+end_export

#+begin_src go <<Auxillary variables>>=
  var rVotes, lVotes int = 0, 0
#+end_src

#+begin_export latex
We choose the winning clade.
#+end_export

#+begin_src go <<Choose winner>>=
  if rVotes > lVotes {
	  cRoot = rChild
	  losVotes = lVotes
	  losLeaves = len(lLeafLabels)
	  winVotes = rVotes
	  winLeaves = rLeafLabels
	  rChild = cRoot.Child
	  lChild = rChild.Sib
  } else {
	  cRoot = lChild
	  losVotes = rVotes
	  losLeaves = len(rLeafLabels)
	  winVotes = lVotes
	  winLeaves = lLeafLabels
	  rChild = cRoot.Child
	  lChild = rChild.Sib
  }
#+end_src

#+begin_export latex
When the iterative voting is over, we print the resulting tree to
\texttt{stdout}. We remove the first character which has to be comma
and add semicolon to the end of the string. If the \texttt{s} flag is
used, we print the stats of the run.
#+end_export

#+begin_src go <<Print the results>>=
  if *optS != false {
  fmt.Printf(
	  "After %d rounds of voting,",
	  round)
  fmt.Printf(
	  "\n a subtree rooted on the node '%s' is found.",
	  cRoot.Label)
  fmt.Printf(
	  "\n The subtree has %d leaves",
	  len(winLeaves))
  fmt.Printf(
	  "\n including %d of %d targets.\n",
	  winVotes, len(targetList))
  fmt.Printf(" The subtree:\n\n")	
  }

  fmt.Printf("%s;\n", cRoot.String()[1:])
#+end_src

#+begin_export latex
TODO:
\begin{enumerate}
\item display an error message if the output tree is the same as the
  input one. Possible reason: names in targets.txt are different from the
  actual leaf names.
\end{enumerate}
#+end_export
